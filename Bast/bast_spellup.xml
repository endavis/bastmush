<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id$ -->
<muclient>
<plugin
   name="bast_spellup"
   author="Bast"
   id="aaaf0c555a44169e0f1d9674"
   language="Lua"
   purpose="Bast's spellup plugin"
   date_written="2008-07-18"
   requires="4.73"
   version="6.1"
   save_state="y"
   >
<description trim="y">
bsp slist      --> list requested self spells

bsp sa all         --> cast all possible spellups
bsp sr all         --> remove all spellups

bsp sa blur  "champion's strength:3"    --> add more to the current list
  to add a spell in a certain place add a : then the place number
bsp sd "night vision" "detect magic"   --> remove those from the list

bsp sba   --> block a spell with another spell
                           (eg. bspell sba 68:121)
bsp sbr   --> remove a block
                           (eg. bspell sbr 68:121)

bsp sdisable --> disable a spell without taking it out of the list
bsp senable --> enabled a disabled self spell

bsp fast    --> cast all spellups immediately, as fast as you can

bsp olist      --> list requested other spells

bsp other (name) --> try to spellup another player with picked spellups
                          (eg. bspell other johnsmith)

bsp other (name) fast --> try to spellup another player with all spellups
                          (eg. bspell other johnsmith fast)

bsp oa aid --> add aid as a requested spellup on others
bsp or aid --> remove aid as a requested spellup on others

bsp odisable --> disable a requested other spell without taking it out of the list
bsp oenable --> enable a disabled other spell

bsp pause   --> stop casting spellups until a resume
bsp resume  --> resume casting
bsp refresh --> requery server for current spells on us

bsp info    --> request info about a spell, shows what the mudside slist returned
bsp export  --> export the spells you have requested and their settings
bsp togglespellup --> toggle a spell to be used as a spellup even if it isn't a mudside spellup spell

bsp help    --> this message

</description>

</plugin>

<!--  Triggers  -->
<triggers>

  <trigger
   enabled="y"
   match="^There is nobody here to help you practice.$"
   name="lefttrainer"
   script="notrainer"
   sequence="100"
   regexp="y"
   omit_from_output="n"
  >
  </trigger>

</triggers>


<!--  Script  -->

<script>
<![CDATA[
internalrevision = "$Rev$"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require 'var'
require 'pluginhelper'
require "tprint"
require "commas"
require "serialize"
require "ldplugin"
require "findfile"
require "verify"
require "aardutils"
require "bastspell"
require "stringfuncs"

nfile = scan_dir_for_file (GetInfo(60), "telnet_options.lua")

if nfile then
  -- pull in telnet option handling
  dofile (nfile)
else
  print("Could not load telnet_options.lua, please copy it to your plugin directory")
end

char = nil

-- phelper.askedself = list of tables with {sn, disabled, blocked}
-- phelper.askedother
askedself_xref = nil
askedother_xref = nil
noneed = false

-- things that can block spells
have_slist = false
waiting = false
need_moves = false
need_mana = false
nocast = false

room = {}

practicing = -1

current_room = -1

function getstatus()
  if phelper.pause then
    return "Paused"
  elseif need_mana then
    return "No mana"
  elseif need_moves then
    return "No moves"
  elseif nocast then
    return "Nocast"
  elseif char and char.status and char.status.state then
    return capitalize(statestrings[tonumber(char.status.state)])
  else
    return 'Unknown'
  end
end

function getwaiting()
  return waiting
end

function getaskedself()
  return serialize.save_simple(phelper.askedself or "")
end

function event_askedself_change()
  phelper:processevent('askedself_change', phelper.askedself)
end

function getaskedother()
  return serialize.save_simple(phelper.askedother or "")
end

function event_askedother_change()
  phelper:processevent('askedother_change', phelper.askedother)
end

function event_status_change()
  local status = getstatus()
  phelper:processevent('status_change', {status=status})
end

function setwaiting(twait)
  waiting = twait
  event_waiting_change()
end

function event_waiting_change()
  local status = getstatus()
  local twaiting = {waiting=waiting}
  if waiting == nil or waiting == false then
    twaiting = {waiting="false"}
  end
  phelper:processevent('waiting_change', twaiting)
end

function isblocked(sn)
  if phelper.askedself and askedself_xref[sn] and phelper.askedself[askedself_xref[sn]].blockers then
    for blocker, _ in pairs(phelper.askedself[askedself_xref[sn]].blockers) do
      if spells['affected'][blocker] then
        return true
      end
    end
  end
  return false
end

function add_blocker(spell, blocker)
  local aspell = find_spell(spell)
  local sn = -1
  if aspell then
    sn = tonumber(aspell.sn)
  else
    print('Add Blocker: could not find spell', spell)
    return false
  end
  local bspell = find_spell(blocker)
  local blksn = -1
  if bspell then
    blksn = tonumber(bspell.sn)
  else
    print('could not find spell', blocker)
    return false
  end
  if sn and blksn and askedself_xref[sn] and phelper.askedself[askedself_xref[sn]] then
    if phelper.askedself[askedself_xref[sn]] then
      if not phelper.askedself[askedself_xref[sn]].blockers then
        phelper.askedself[askedself_xref[sn]].blockers = {}
      end
      phelper.askedself[askedself_xref[sn]].blockers[blksn] = 1
      return true
    end
  end
  return false
end -- add_disabled

function remove_blocker(spell, blocker)
  local aspell = find_spell(spell)
  local sn = -1
  if aspell then
    sn = tonumber(aspell.sn)
  else
    print('Remove blocker: could not find spell', spell)
    return false
  end
  local bspell = find_spell(blocker)
  local blksn = -1
  if bspell then
    blksn = tonumber(bspell.sn)
  else
    print('could not find spell', blocker)
    return false
  end
  if sn and blksn and askedself_xref[sn] and phelper.askedself[askedself_xref[sn]] then
    if phelper.askedself[askedself_xref[sn]] then
      phelper.askedself[askedself_xref[sn]].blockers[blksn] = nil
    end
    return true
  end
  return false
end

function cmd_refresh(cmddict)
  setwaiting(false)
  noneed = false
  local bsstcmd = GetPluginVariable('aaa72f3b5453567e2bba9d50', 'cmd')
  if bsstcmd ~= nil and bsstcmd ~= '' then
     Execute(bsstcmd .. " refresh")
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", "Refreshing affected spells and resetting events")
end

function make_askedself_xrefs ()
  phelper:mdebug('making askedself xref')
  askedself_xref = {}
  for k, v in pairs (phelper.askedself) do
    askedself_xref[v.sn] = k
  end -- for each spell
  event_askedself_change()
end -- make_xrefs

function make_askedother_xrefs ()
  phelper:mdebug('making askedother xref')
  askedother_xref = {}
  for k, v in pairs (phelper.askedother) do
    askedother_xref[v.sn] = k
  end -- for each spell
  event_askedother_change()
end -- make_xrefs

function activatespell(sn, fast)
  fast = verify_bool(fast)
  if phelper.askedself[askedself_xref[sn]] then
    v = phelper.askedself[askedself_xref[sn]]
    if not spells['affected'][sn] then
      local cast = true
      if not spells['all'] or not spells['all'][sn] then
        return false
      end
      local recov = spells['all'][sn].recovery
      if recov and recoveries['affected'][recov] then
        cast = false
      end
      if v.disabled or isblocked(sn) or practicing == sn then
        cast = false
      end
      if not spells['learned'][sn] then
        cast = false
      end
      if cast then
        if not fast then
          --print("setting waiting to", sn)
          setwaiting(tonumber(sn))
        end
        if tonumber(spells['all'][sn]['type']) == 1 then
          if phelper.selfargs[sn] then
            SendNoEcho('cast ' .. tostring(sn) .. ' ' .. tostring(phelper.selfargs[sn]))
          else
            SendNoEcho('cast ' .. tostring(sn))
          end
        else
          words = justWords(spells['all'][sn].name)
          SendNoEcho(words[1])
        end
        return true
      end
    end
  end
  return false
end

function cmd_check(cmddict)
  local format = "%-10s : %-7s (%s)"
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "have_slist", tostring(have_slist), "should be true to cast spells, false means the plugin hasn't seen a list of spells"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "waiting", tostring(waiting), "the spell that the plugin is waiting to see"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "noneed", tostring(noneed), "should be true unless you have spells waiting to be cast"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "need_mana", tostring(need_mana), "should be false to cast spells, true means your mana has not increased"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "need_moves", tostring(need_moves), "should be false to cast spells, true means your moves have not increased"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "nocast", tostring(nocast), "should be false to cast spells, true means you are in a nocast room"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "paused", tostring(phelper.pause), "should be false to cast spells, true means the plugin is paused"))
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format, "state", tostring(char.status.state), "should be 3 to cast spells, any other number means we cannot cast"))

  ColourNote(RGBColourToName(var.plugin_colour), "black", "The below should all be yes")

  local format2 = '%-25s : %s'
  if spells['all'] then
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "spells['all']", "yes"))
  else
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "spells['all']", "no"))
  end
  if spells['affected'] then
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "spells['affected']", "yes"))
  else
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "spells['affected']", "no"))
  end
  if spells['learned'] then
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "spells['learned']", "yes"))
  else
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "spells['learned']", "no"))
  end
  if recoveries['all'] then
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "recoveries['all']", "yes"))
  else
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "recoveries['all']", "no"))
  end
  if recoveries['affected'] then
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "recoveries['affected']", "yes"))
  else
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "recoveries['affected']", "no"))
  end
  if char ~= nil then
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "char", "yes"))
  else
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format(format2, "char", "no"))
  end

end



function nextspellup (reason)
  --print("called nextspellup", reason)
  if have_slist and
     char ~= nil and
     not waiting and
     not need_mana and
     not need_moves and
     not noneed and
     not nocast and
     not phelper.pause and
     tonumber(char.status.state) == 3 then

    --print('got to go through table')
    for k,v in ipairs(phelper.askedself) do
      if activatespell(v.sn) then
        return
      end
    end
    noneed = true

  end
end

function formatheader()
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", "#. Name"),
             "yellow",          "black", string.format("%-3s", " P "),
             "seagreen",        "black", string.format("%-3s", " B "),
             "orange",          "black", string.format("%-3s", " D "),
             "orange",          "black", string.format("%-4s", " NP "),
             "orange",          "black", string.format("%-4s", " NL "))
  ColourNote(RGBColourToName(var.plugin_colour), "black",   "____________________________________________________")
end

function formatspell(spell, colour)
  if not colour then
    colour = var.plugin_colour
  end
  local name = spells['all'][spell.sn].name
  local disabled = ""
  local blocked = ""
  local tstring = ""
  if spell.disabled then
    disabled = "Yes"
  end
  if spell.blockers then
    for sn,t in pairs(spell.blockers) do
      blocked = blocked .. " " .. spells['all'][sn].name
    end
  end
  ColourNote(RGBColourToName(colour), "black", string.format("%-25s" , name),
             RGBColourToName(colour), "black", string.format("%-5s" , spell.sn),
             RGBColourToName(colour), "black", string.format("%-10s", disabled),
             RGBColourToName(colour), "black", string.format("%-10s", blocked))
end

function cmd_slist(cmddict)
  phelper:plugin_header("Spells requested (" .. tostring(#phelper.askedself) .. ")")
  if waiting then
    ColourNote(RGBColourToName(var.plugin_colour), "black", "Waiting: " .. spells['all'][waiting].name .. " (" .. waiting .. ")")
  end
  formatheader()
  local tnoprac = {}
  local tgood = {}
  local tdisable = {}
  count = 0
  for i,j in ipairs(phelper.askedself) do
    count = count + 1
    local v = spells['all'][tonumber(j.sn)]
    local noprac = "   "
    local nolearn = "   "
    local disabled = "   "
    local blocked = "   "
    local pending = "   "
    local blockedby = "   "
    if spells['notpracticed'][tonumber(v.sn)] then
      noprac = " NP "
    elseif spells['notlearned'][tonumber(v.sn)] then
      nolearn = " NL "
    end
    if j.blockers then
      for blocker, _ in pairs(j.blockers) do
        if not spells['affected'][tonumber(v.sn)] and spells['affected'][blocker] then
          blocked = " B "
          blockedby = "  Blocked by spell: " .. spells['affected'][blocker].name
        end
      end
    end
    local trec = spells['all'][tonumber(j.sn)].recovery
    if trec and recoveries['affected'][tonumber(trec)] then
      blocked = " B "
      blockedby = "  Blocked by Recovery: " .. recoveries['affected'][tonumber(trec)].name
    end
    if j.disabled then
      disabled = " D "
    end
    if not spells['affected'][tonumber(v.sn)] and not j.disabled and not (v.percent <= 1) and blocked == "   " then
      pending = " P "
    end

    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", count .. ". " .. v.name),
               "yellow", "black", string.format("%-3s", pending),
               "seagreen",  "black", string.format("%-3s", blocked),
               "orange", "black", string.format("%-3s", disabled),
               "orange", "black", string.format("%-4s", noprac),
               "orange", "black", string.format("%-4s", nolearn),
               "orange", "black", blockedby)
  end
end

function cmd_pause(cmddict)
  phelper:plugin_header("Spellup Paused")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Paused")
  phelper.pause = true
  event_status_change()
end

function cmd_resume(cmddict)
  phelper:plugin_header("Spellup Resumed")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Resumed")
  phelper.pause = false
  noneed = false
  event_status_change()
  nextspellup("resumed")
end

function cmd_sablocker(cmddict)
  if #cmddict >= 1 then
    local ablocked = false
    phelper:plugin_header()
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        local spell = tlist[1]
        local blck = tlist[2]
        spell = find_spell(spell)
        blck = find_spell(blck)
        if not spell then
          ColourNote(RGBColourToName(var.plugin_colour), "black", 'Spell ' .. tlist[1] .. ' does not exist')
          return
        end
        if not blck then
          ColourNote(RGBColourToName(var.plugin_colour), "black", 'Spell ' .. tlist[2] .. ' does not exist')
          return
        end
        local test = add_blocker(spell.sn, blck.sn)
        if test then
          ablocked = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(spell.sn)].name .. " is now blocked by " .. spells['all'][tonumber(blck.sn)].name)
        end
      end
    end
    if ablocked then
      event_askedself_change()
    end
  else
    phelper:plugin_header('sba')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " sba <blockspell:isactive> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "add a blocker for a spell on self")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a pair of spells seperated by a colon (:)")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "  The leftside of the colon is the spell that will not be cast")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", '  if the spell on the rightside of the colon is active')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", 'Example: ')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", ' block protection good from being cast if inertial barrier is active')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", ' ' .. phelper.cmd .. ' sba 68:121')
  end
  return true
end

function cmd_sdblocker(cmddict)
  if #cmddict >= 1 then
    local rblocked = false
    phelper:plugin_header()
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        if remove_blocker(sn, blck) then
          rblocked = true
        end
      end
    end
    if rblocked then
      event_askedself_change()
    end
  else
    phelper:plugin_header('sbr')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " sbr <blockspell:isactive> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "remove a blocker for a spell on self")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a pair of spells seperated by a colon (:)")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "  The leftside of the colon is the spell that will not be cast")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", '  if the spell on the rightside of the colon is active')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", 'Example: ')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", ' remove the blocker: protection good from being cast if inertial barrier is active')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", ' ' .. phelper.cmd .. ' sbr 68:121')
  end
  return true
end


function cmd_sdisable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()
    local disabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedself_xref[sn] ~= nil then
            phelper.askedself[askedself_xref[sn]].disabled = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " disabled")
            disabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")
          end
        end
      else
        print('Disable: could not find spell', item)
      end
    end
    if disabled then
      event_askedself_change()
    end
  else
    phelper:plugin_header('sdisable')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " sdisable <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "disable a spell from being cast on self")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell")
  end
end

function cmd_senable(cmddict)
  if #cmddict >= 1 then
    local enabled = false
    phelper:plugin_header()
    if cmddict[1] == 'all' then
      for i,j in ipairs(phelper.askedself) do
        if phelper.askedself[i].disabled then
          phelper.askedself[i].disabled = false
          enabled = true
        end
      end
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells enabled")
    else
      for i,item in ipairs(cmddict) do
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if askedself_xref[sn] ~= nil then
              phelper.askedself[askedself_xref[sn]].disabled = false
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " enabled")
              enabled = true
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")
            end
          end
        else
          print('Enable: could not find spell', item)
        end
      end
    end
    if enabled then
      noneed = false
      event_askedself_change()
      nextspellup("spells enabled")
    end
  else
    phelper:plugin_header('senable')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " senable <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "enable a spell to be cast on self")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell")
  end
end

function cmd_export(cmddict)
  local tdict = {}
  local tblock = {}
  local tdisabled = {}
  for i,v in ipairs(phelper.askedself) do
    table.insert(tdict, tostring(v.sn))
    if v.disabled then
      table.insert(tdisabled, tostring(v.sn))
    end
    if v.blockers then
      for f,u in pairs(v.blockers) do
        table.insert(tblock, tostring(v.sn) .. ':' .. tostring(f))
      end
    end
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " sremove all")
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " sadd " .. table.concat(tdict, " "))
  local tstring = ""
  if next(tblock) then
    local tblocks = phelper.cmd .. " sba " .. table.concat(tblock, " ")
    ColourNote(RGBColourToName(var.plugin_colour), "black", tblocks)
  end
  if next(tdisabled) then
    local tdis = phelper.cmd .. " sdisable " .. table.concat(tdisabled, " ")
    ColourNote(RGBColourToName(var.plugin_colour), "black", tdis)
  end
  if next(phelper.selfargs) then
    for i,v in pairs(phelper.selfargs) do
      local targ = phelper.cmd .. " searg " .. tostring(i) .. " " .. tostring(v)
      ColourNote(RGBColourToName(var.plugin_colour), "black", targ)
    end
  end
  local tdict = {}
  local tdisabled = {}
  for i,v in ipairs(phelper.askedother) do
    if v.disabled then
      table.insert(tdisabled, tostring(v.sn))
    end
    table.insert(tdict, tostring(v.sn))
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " oremove all")
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " oadd " .. table.concat(tdict, " "))
  if next(tdisabled) then
    local tdis = phelper.cmd .. " odisable " .. table.concat(tdisabled, " ")
    ColourNote(RGBColourToName(var.plugin_colour), "black", tdis)
  end

end

function formatitem(row, data)
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format('%-20s: %s', tostring(row), tostring(data)))
end

function cmd_info(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header('Info')
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        formatitem("Name", aspell.name)
        formatitem("SN", aspell.sn)
        formatitem("Type", aspell.type)
        formatitem("Target", spelltarget_table[tonumber(aspell.target)])
        formatitem("Prac %", aspell.percent)
        if aspell.spellup == 1 then
          formatitem("Spellup", "Yes")
        else
          formatitem("Spellup", "No")
        end
        if aspell.clientspellup == 1 then
          formatitem("Client Spellup", "Yes")
        else
          formatitem("Client Spellup", "No")
        end
        if aspell.clanskill == 1 then
          formatitem("Clan Skill", "Yes")
        else
          formatitem("Clan Skill", "No")
        end
        if aspell.recovery ~= -1 then
          formatitem("Recovery", recoveries['all'][aspell.recovery].name)
        end
        local tstring = "No"
        local blockers = ""
        if askedself_xref[aspell.sn] and phelper.askedself[askedself_xref[aspell.sn]] then
          tstring = "Yes"
          if phelper.askedself[askedself_xref[aspell.sn]].disabled then
            tstring = tstring .. " - Disabled"
          end
          if phelper.askedself[askedself_xref[aspell.sn]].blockers then
            for i,v in pairs(phelper.askedself[askedself_xref[aspell.sn]].blockers) do
              if blockers == "" then
                blockers = spells['all'][i].name
              else
                blockers = blockers .. ", " .. spells['all'][i].name
              end
            end
          end
        end
        formatitem("Requested", tstring)
        if blockers ~= "" then
          formatitem("Blockers", blockers)
        end
        if spells['affected'][aspell.sn] and spells['affected'][aspell.sn].duration then
          formatitem("Duration", SecondsToClock(spells['affected'][aspell.sn].finish - GetInfo(304)))
        end
        ColourNote("black","black", "")
      else
        print('Info: could not find spell', item)
      end
    end
  else
    phelper:plugin_header('info')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " info <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "show info about a spell")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_togglespellup(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header("Toggle Spellup")
    local sspells = {}
    local uspells = {}
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        if aspell.clientspellup == 0 or not aspell.clientspellup then
          sspells[aspell.sn] = aspell
          aspell.clientspellup = 1
          ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " set to be a spellup.")
        else
          uspells[aspell.sn] = aspell
          aspell.clientspellup = 0
          ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " is no longer a spellup.")
        end
      end
    end
    local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "setclientspellup", serialize.save_simple(sspells))
    local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "unsetclientspellup", serialize.save_simple(uspells))
  else
    phelper:plugin_header('togglespellup')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " togglespellup <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "toggle a spell to be a spellup")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_toggleclanskill(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header("Toggle Clan Skill")
    local sspells = {}
    local uspells = {}
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        if aspell.spellup == 1 or aspell.clientspellup == 1 then
          if aspell.clanskill == 0 or not aspell.clanskill then
            sspells[aspell.sn] = aspell
            aspell.clanskill = 1
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " set to be a clan skill.")
          else
            uspells[aspell.sn] = aspell
            aspell.clanskill = 0
            if waiting == aspell.sn then
              setwaiting(false)
            end
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " is no longer a clan skill.")
          end
        else
          ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " is not a spellup.")
          return
        end
      end
    end
    local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "setclanskill", serialize.save_simple(sspells))
    local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "unsetclanskill", serialize.save_simple(uspells))
  else
    phelper:plugin_header('toggleclanskill')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " toggleclanskill <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "toggle a spell to be a clanskill, which will make a spell be able to be cast if you have not practiced it")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_fast(cmddict)
  for i,v in ipairs(phelper.askedself) do
    activatespell(tonumber(v.sn), true)
  end
end

function cmd_other(cmddict)
  local who = cmddict[1]

  if not who then
    phelper:plugin_header('other')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " other <target> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "spellup another person")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a character or mob in the same room")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "  if the keyword 'fast' is used, then it will cast all spellup spells")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "  and not just the ones in the other list")
    return
  end
  if cmddict[2] == 'fast' then
    for sn, v in pairs (spells['spellup']) do
      if spells['learned'][tonumber(v.sn)] and   -- we know it
        v.spellup == 1 and       -- it is a spellup
        v.target == 2 and   -- can be cast on others
        v.type == 1 then   -- spell not skill
          Send ("cast " .. tostring(v.sn) .. " " .. who)  -- cast it
      end -- if possible to spellup this one
    end -- for
  else
    for i, v in ipairs(phelper.askedother) do
      if spells['learned'][tonumber(v.sn)] and   -- we know it
        spells['all'][v.sn].spellup == 1 and       -- it is a spellup
        spells['all'][v.sn].target == 2 and   -- can be cast on others
        spells['all'][v.sn].type == 1 then   -- spell not skill
          Send ("cast " .. tostring(v.sn) .. " " .. who)  -- cast it
      end
    end
  end
end

function cmd_oadd(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header("Added spells to be cast on others")
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        --tprint(sn)
        if sn then
          if aspell.spellup ~= 1 and aspell.clientspellup ~= 1 then
            ColourNote ("red", "", "Spell '" .. aspell.name .. "' is not a spellup.")
          else
            if cancastother(sn) then
              --tprint(askedother_xref)
              if askedother_xref == nil or askedother_xref[tonumber(sn)] == nil then
                if aspell.clanskill == 0 then
                  if aspell.percent == 1 then
                    ColourNote ("red", "", "You have not practiced '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                  elseif aspell.percent == 0 then
                    ColourNote ("red", "", "You have not learned '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                  end
                end
                phelper:mdebug('adding ', item, sn, aspell.name)
                table.insert(phelper.askedother, {sn=tonumber(sn)})
                make_askedother_xrefs()
                ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. aspell.name)
              else
                ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " already in list")
              end
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " cannot be cast on another")
            end
          end
        else
          print('Add spell: could not find', item)
        end
      end
    end
  else
    phelper:plugin_header('oadd')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " oadd <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "add a spell to be cast on others")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_oremove(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header("Removed spells to be cast on others")
    if cmddict[1] == 'all' then
      phelper.askedother = {}
      make_askedother_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if askedother_xref[sn] ~= nil then
              table.remove(phelper.askedother, askedother_xref[sn])
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " removed")
              removed = true
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")
            end
          end
        else
          print('Delete Spell: could not find spell', item)
        end
      end
      if removed then
        make_askedother_xrefs()
      end
    end
  else
    phelper:plugin_header('oremove')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " oremove <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "remove a spell to be cast on others")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_odisable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()
    local disabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedother_xref[sn] ~= nil then
            phelper.askedother[askedother_xref[sn]].disabled = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " disabled for casting on others")
            disabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")
          end
        end
      else
        print('Disable: could not find spell', item)
      end
    end
    if disabled then
      event_askedother_change()
    end
  else
    phelper:plugin_header('odisable')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " odisable <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "disable a spell to be cast on others")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_oenable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()
    local enabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedother_xref[sn] ~= nil then
            phelper.askedother[askedother_xref[sn]].disabled = false
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " enabled for casting on others")
            enabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")
          end
        end
      else
        print('Enable: could not find spell', item)
      end
    end
    if enabled then
      event_askedother_change()
    end
  else
    phelper:plugin_header('oenable')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " oenable <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "enable a spell to be cast on others")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end


function formatotherheader()
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", "#. Name"),
             "orange",          "black", string.format("%-3s", " D "),
             "orange",          "black", string.format("%-4s", " NP "),
             "orange",          "black", string.format("%-4s", " NL "))
  ColourNote(RGBColourToName(var.plugin_colour), "black",   "____________________________________________________")
end


function cmd_olist(cmddict)
  phelper:plugin_header("Spells requested for others (" .. tostring(#phelper.askedother) .. ")")
  formatotherheader()
  local tnoprac = {}
  local tgood = {}
  local tdisable = {}
  local count = 0
  for i,j in ipairs(phelper.askedother) do
    count = count + 1
    local v = spells['all'][tonumber(j.sn)]
    local noprac = "   "
    local nolearn = "   "
    local disabled = "   "
    local blocked = "   "
    local pending = "   "
    if spells['notpracticed'][tonumber(v.sn)] then
      noprac = " NP "
    elseif spells['notlearned'][tonumber(v.sn)] then
      nolearn = " NL "
    end
    if j.disabled then
      disabled = " D "
    end

    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", count .. ". " .. v.name),
               "orange", "black", string.format("%-3s", disabled),
               "orange", "black", string.format("%-4s", noprac),
               "orange", "black", string.format("%-4s", nolearn))
  end
end

function cmd_sremove(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header()
    if cmddict[1] == 'all' then
      phelper.askedself = {}
      make_askedself_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if askedself_xref[sn] ~= nil then
              table.remove(phelper.askedself, askedself_xref[sn])
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " removed")
              removed = true
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")
            end
          end
        else
          print('Delete Spell: could not find spell', item)
        end
      end
      if removed then
        make_askedself_xrefs()
      end
    end
  else
    phelper:plugin_header('sremove')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " sremove <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "remove a spell to be cast on self")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
  end
end

function cmd_searg(cmddict)
  if #cmddict ~= 2 then
    phelper:plugin_header('searg')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " searg <spell> <argument>")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "add an argument to cast with a a spell")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) argument to the spell, 'None' to remove the argument for the spell")
    return
  end
  local aspell = find_spell(cmddict[1])
  local args = cmddict[2]
  if not aspell then
    ColourNote(RGBColourToName(var.plugin_colour), "black", "Spell " .. tostring(cmddict[1]) .. " could not be found")
    return
  end
  if args:lower() == 'none' then
    phelper.selfargs[tonumber(aspell.sn)] = nil
    ColourNote(RGBColourToName(var.plugin_colour), "black", "Spell " .. tostring(aspell.name) .. " will be cast with no args")
  else
    phelper.selfargs[tonumber(aspell.sn)] = args
    ColourNote(RGBColourToName(var.plugin_colour), "black", "Spell " .. tostring(aspell.name) .. " will be cast with args, " .. tostring(args))
  end

end

function cmd_sadd(cmddict)
  if #cmddict >= 1 then
    local added = false
    phelper:plugin_header()
    if cmddict[1] == 'all' then
      if next(phelper.askedself) then
          ColourNote(RGBColourToName(var.plugin_colour), "black", "You have requested to add all spellups, if you want to use all please remove all requested spellups ")
          return
      end
      phelper.askedself = {}
      for i,v in pairs(spells['spellup']) do
        if spells['learned'][tonumber(v.sn)] then
          ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. v.name)
          table.insert(phelper.askedself, {sn=tonumber(i)})
        end
      end
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells added")
      make_askedself_xrefs()
      nextspellup("added new spells")
    else
      for i,item in ipairs(cmddict) do
        local place = nil
        colonplace, _ = string.find(item, ':')
        if colonplace and colonplace > 0 then
          tlist = utils.split(item, ':')
          item = tlist[1]
          place = tlist[2]
        end
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if aspell.spellup ~= 1 and aspell.clientspellup ~= 1 then
              ColourNote ("red", "", "Spell '" .. aspell.name .. "' is not a spellup.")
            else
              if askedself_xref[tonumber(sn)] == nil then
                if aspell.clanskill == 0 then
                  if aspell.percent == 1 then
                    ColourNote ("red", "", "You have not practiced '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                  elseif aspell.percent == 0 then
                    ColourNote ("red", "", "You have not learned '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                  end
                end
                phelper:mdebug('adding ', item, sn, aspell.name, place)
                local pos = -1
                if place then
                  table.insert(phelper.askedself,place, {sn=tonumber(sn)})
                  pos = tostring(place)
                else
                  table.insert(phelper.askedself, {sn=tonumber(sn)})
                  pos = tostring(#phelper.askedself)
                end
                make_askedself_xrefs()
                added = true
                ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. aspell.name .. " in position " .. pos)
              else
                ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " already in list")
              end
            end -- if
          else
            print('Add spell: could not find', item)
          end
        end
      end -- if number orname found
      if added then
        noneed = false
        --make_askedself_xrefs()
        nextspellup("added new spells")
      end
    end
  else
    phelper:plugin_header('sadd')
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Usage: " .. phelper.cmd .. " sadd <spell> ")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "add a spell to be cast on self")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "(required) a spell, can be multiple")
    ColourNote(RGBColourToName(phelper.plugin_colour), "black", "  if the keyword 'all' is used, then all spellup spells you have practiced will be added")
  end
end

function formatspells()
  if not next(phelper.askedself) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedself) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end

function formatother()
  if not next(phelper.askedother) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedother) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end

function check_slist()
    if not have_slist and spells['all'] and recoveries['all'] and recoveries['affected'] and spells['affected'] and spells['learned'] then
      --print("have slist")
      have_slist = true
      nextspellup('has slist')
    end
end

function tresume()
  phelper.pause = false
  event_status_change()
end

function hasarg(spell)
  local aspell = find_spell(spell)
  if aspell then
    if phelper.selfargs[tonumber(aspell.sn)] then
      return true
    end
  end
  return false
end

function notrainer(name, line, wildcards)
  if practicing ~= -1 then
    practicing = -1
    phelper:unregister_remote("aaa72f3b5453567e2bba9d50", "skillprac", "onskillgain", true)
  end
end

function onskillgain(args)
  local targs = assert (loadstring ('return ' .. args or ""))()
  --tprint(targs)
  --print('pracs', tonumber(char.worth.pracs))
  spells['all'][tonumber(targs.sn)]['percent'] = tonumber(targs.percent)
  if (practicing == tonumber(targs.sn) and tonumber(targs.percent) >= tonumber(phelper.practo)) or char.worth and tonumber(char.worth.pracs) == 0 then
    practicing = -1
    if not spells['learned'][tonumber(targs.sn)] then
      spells['learned'][tonumber(targs.sn)] = copytable.deep(spells['all'][tonumber(targs.sn)])
    end
    --print('unregistering because I am done practicing', targs.sn)
    phelper:unregister_remote("aaa72f3b5453567e2bba9d50", "skillprac", "onskillgain", true)
    nextspellup('skillprac')
  elseif practicing == tonumber(targs.sn) and char.worth then
    char.worth.pracs = tonumber(char.worth.pracs) - 1
    SendNoEcho('practice ' .. tostring(practicing))
    return
  end
  if char and char.worth and tonumber(char.worth.pracs) > 0 then
    pracskill()
  end
end

function pracskill(sn)
  --print('autoprac', phelper.autoprac)
  --print('char.status.state', char.status.state)
  --print('trainer room', string.find(room.details, "trainer"))
  --print('practicing', practicing)
  if not char or not char.worth or tonumber(char.worth.pracs) == 0 then
    return
  end
  if phelper.autoprac and tonumber(char.status.state) == 3 and string.find(room.details, "trainer") then
    --print('got this far')
    if practicing ~= -1 and practicing > 0 and sn then
      phelper:register_remote("aaa72f3b5453567e2bba9d50", "skillprac", "onskillgain", true)
      char.worth.pracs = tonumber(char.worth.pracs) - 1
      SendNoEcho('practice ' .. tostring(sn))
    else
      --print('checking all spells')
      for i,j in ipairs(phelper.askedself) do
        local sn = j['sn']
        --print(sn, spells['all'][sn]['percent'])
        if tonumber(spells['all'][sn]['percent']) < phelper.practo and not spells['notlearned'][sn] and practicing == -1 and spells['all'][sn].clanskill == 0 and tonumber(char.worth.pracs) > 0 then
          --print('practicing', sn)
          practicing = sn
          phelper:register_remote("aaa72f3b5453567e2bba9d50", "skillprac", "onskillgain", true)
          char.worth.pracs = tonumber(char.worth.pracs) - 1
          SendNoEcho('practice ' .. tostring(sn))
        end
      end
    end
  end
end

function loadall()
  load_spells("all")
  --load_spells_xrefs()
  load_spells("affected")
  load_spells("spellup", true)
  load_spells("learned")
  load_spells("notpracticed")
  load_spells("notlearned")
  --print('loading recoveries in enable')
  load_recoveries("all")
  load_recoveries("affected")
end
]]>
</script>

<script>
<![CDATA[

function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)

  local old_mana = -1
  local old_moves = -1
  local old_state = -1
  if char and char.vitals then
    old_mana = tonumber(char.vitals.mana)
    old_moves = tonumber(char.vitals.moves)
  end
  if char and char.status then
    old_state = tonumber(char.status.state)
  end
  if id == "aaa0ab9ed92f8fc614664bd1" then
    if msg == 5 or msg == 7  then
      phelper.pause = true
      event_status_change()
    elseif msg == 6 or msg == 8 then
      DoAfterSpecial(5, 'loadall()', 12)
      DoAfterSpecial(10, 'tresume()', 12)
    end
  end
  if id == '3e7dedbe37e44942dd46d264' then
    if text:find("char") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
      char = assert (loadstring ('return ' .. gmcparg or ""))()
      if char['vitals'] and char['stats'] and char['maxstats'] and char['worth'] and char['status'] and char['base'] then
        if tonumber(char.vitals.mana) > old_mana then
          -- more mana
          need_mana = false
          event_status_change()
          nextspellup('more mana')
        end
        if tonumber(char.vitals.moves) > old_moves then
          -- more moves
          need_moves = false
          event_status_change()
          nextspellup('more moves')
        end
        if tonumber(char.status.state) == 3 and old_state ~= 3 and old_state ~= 12 then
          -- state changed to active from something else
          setwaiting(false)
          nextspellup('state change to active')
        end
        if old_state ~= tonumber(char.status.state) then
          event_status_change()
        end
      end

    end
    if text:find("room.info") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
      room = assert (loadstring ('return ' .. gmcparg or ""))()
      current_room = room.num
      if phelper.nocast_rooms[tonumber(current_room)] then
        phelper:mdebug('setting nocast true for', current_room, room.name)
        nocast = true
        event_status_change()
      else
        if nocast then
          nocast = false
          event_status_change()
          nextspellup('left nocast room')
        end
      end
      pracskill()
    end
  end
  if id == 'aaa72f3b5453567e2bba9d50' then
    if msg == 5 then
      -- spell casting failure
      local tag = assert (loadstring ('return ' .. text or ""))()
      if tag.reason == 1 then
        if askedself_xref[tonumber(tag.sn)] ~= nil then
          setwaiting(false)
          nextspellup('spell fail')
        end
      elseif tag.reason == 2 then
        local tagsn = tonumber(tag.sn)
        if askedself_xref[tonumber(tag.sn)] ~= nil then
          local tagsn = tonumber(tag.sn)
          if tagsn == waiting then
            phelper.askedself[askedself_xref[tagsn]].disabled = true
            ColourNote("red", "black", spells['all'][tagsn].name .. " disabled because the affect already exists.")
            make_askedself_xrefs()
            setwaiting(false)
            nextspellup('spell fail')
          end
        end
      elseif tag.reason == 3 then
        setwaiting(false)
        nextspellup('spell fail')
      elseif tag.reason == 4 then
        setwaiting(false)
        need_mana = true
        event_status_change()
      elseif tag.reason == 5 then
        if current_room ~= -1 then
          phelper.nocast_rooms[tonumber(current_room)] = true
        end
        nocast = true
        setwaiting(false)
        event_status_change()
      elseif tag.reason == 6 then
        setwaiting(false)
      elseif tag.reason == 8 then
        local tagsn = tonumber(tag.sn)
        if askedself_xref[tonumber(tag.sn)] ~= nil then
          local tagsn = tonumber(tag.sn)
          if tagsn == waiting then
            if not spells['notlearned'][tag.sn] then
              phelper.askedself[askedself_xref[tagsn]].disabled = true
              ColourNote("red", "black", spells['all'][tagsn].name .. " disabled because you can't cast this spell.")
              make_askedself_xrefs()
            end
            setwaiting(false)
            nextspellup('spell fail')
          end
        end
      elseif tag.reason == 10 then
        setwaiting(false)
      elseif tag.reason == 11 then
        -- remove from askedself list
        local tagsn = tonumber(tag.sn)
        if tagsn == waiting then
          ColourNote("red", "black", spells['all'][tagsn].name .. " disabled because it is disabled mudside.")
          phelper.askedself[askedself_xref[tagsn]].disabled = true
          setwaiting(false)
        end
      elseif tag.reason == 12 then
        need_moves = true
        setwaiting(false)
        event_status_change()
      end
    elseif msg == 7 then
      -- all spells
      load_spells('all')
      check_slist()

    elseif msg == 8 then
      -- learned spells
      load_spells('learned')
      load_spells('notlearned')
      load_spells('notpracticed')
      noneed = false
      nextspellup('learned change')
      check_slist()

    elseif msg == 9 then
      -- spellup spells
      load_spells('spellup', true)

    elseif msg == 10 then
      -- affected spells
      load_spells('affected')
      if waiting then
        if spells['affected'][waiting] then
          setwaiting(false)
        end
      end
      check_slist()
      noneed=false
      nextspellup('spells affected change')

    elseif msg == 11 then
      -- recoveries all
      load_recoveries('all')
      check_slist()

    elseif msg == 12 then
      -- recoveries affected
      load_recoveries('affected')
      noneed=false
      check_slist()
      nextspellup('recovery affected change')

    end

  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()
  --OnPluginDisable is automatically called by pluginhelper

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_spellsskills", "aaa72f3b5453567e2bba9d50")
  ldplugin ("pluginlist", "e8520531407cb4281bea544e")

  phelper:OnPluginEnable()
  if IsConnected() then
    load_spells("all")
    --load_spells_xrefs()
    load_spells("affected")
    load_spells("spellup", true)
    load_spells("learned")
    load_spells("notpracticed")
    load_spells("notlearned")
    --print('loading recoveries in enable')
    load_recoveries("all")
    load_recoveries("affected")
    if spells['all'] and recoveries['all'] and recoveries['affected'] and spells['affected'] and spells['learned'] then
      --print("have slist")
      have_slist = true
      nextspellup('has slist')
    end
    CallPlugin("3e7dedbe37e44942dd46d264","Send_GMCP_Packet","request char")
  end

  if askedself_xref == nil then
    make_askedself_xrefs ()
  end
  if askedother_xref == nil then
    make_askedother_xrefs ()
  end
end -- OnPluginEnable

function OnPluginDisable ()
  if GetPluginInfo(GetPluginID (), 17) and IsConnected() then
    --TelnetOptionOff (TELOPT_SPELLUP)
    --TelnetOptionOff (TELOPT_SKILLGAINS)
  end

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  TelnetOptionOn (TELOPT_SPELLUP)
  TelnetOptionOn (TELOPT_SKILLGAINS)

  have_slist = false

  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  have_slist = false
  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

]]>
</script>

<script>
<![CDATA[

phelper:set_default('cmd', 'bsp')
phelper:set_default('plugin_colour', 'lime')

phelper:add_setting( 'askedself', {type="table", help="the list of spells to use on self", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatspells, readonly=true, after=make_askedself_xrefs})
phelper:add_setting( 'selfargs', {type="table", help="a table for spells that need arguments", default=serialize.save_simple({}), sortlev=36, istable=true, readonly=true})
phelper:add_setting( 'askedother', {type="table", help="the list of spells to use on other", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatother, readonly=true, after=make_askedother_xrefs})
phelper:add_setting( 'nocast_rooms', {type="table", help="the list of rooms that are nocast", default=serialize.save_simple({}), sortlev=35, istable=true, readonly=true})
phelper:add_setting( 'pause', {type="bool", help="pause spellup", default=false, sortlev=35, readonly=true})
phelper:add_setting( 'autoprac', {type="bool", help="auto practice skills/spells in your spellup list", default=false, sortlev=36})
phelper:add_setting( 'practo', {type="number", help="the percentage to practice spells to", default=85, sortlev=36})


phelper:add_cmd('slist', {func=cmd_slist, help="list requested spells for self", default=true, sortgroup='self', prio=10})
phelper:add_cmd('sadd', {func=cmd_sadd, help="add a spell to cast on self, use 'all' to add all spellups", sortgroup='self', prio=11})
phelper:add_cmd('sremove', {func=cmd_sremove, help="remove a spell, use 'all' to clear table", sortgroup='self', prio=12})
phelper:add_cmd('senable', {func=cmd_senable, help="enable a spell", sortgroup='self', prio=13})
phelper:add_cmd('sdisable', {func=cmd_sdisable, help="disable a spell", sortgroup='self', prio=14})
phelper:add_cmd('sba', {func=cmd_sablocker, help="add blockers, Ex. 'protection good:inertial barrier'", sortgroup='self', prio=15})
phelper:add_cmd('sbr', {func=cmd_sdblocker, help="remove blockers", sortgroup='self', prio=16})
phelper:add_cmd('fast', {func=cmd_fast, help="cast all spells requested in one go", sortgroup='self', prio=17})

phelper:add_cmd('olist', {func=cmd_olist, help="list spells to be cast on other", sortgroup='other', prio = 30})
phelper:add_cmd('oadd', {func=cmd_oadd, help="add spells to cast on other", sortgroup='other', prio = 31})
phelper:add_cmd('oremove', {func=cmd_oremove, help="remove spells to cast on other", sortgroup='other', prio = 32})
phelper:add_cmd('oenable', {func=cmd_oenable, help="enable a spell", sortgroup='other', prio = 33})
phelper:add_cmd('odisable', {func=cmd_odisable, help="disable a spell", sortgroup='other', prio = 34})
phelper:add_cmd('other', {func=cmd_other, help="cast spells on another char, use 'fast' to cast all spellup spells, otherwise it only casts the ones added with oadd", sortgroup='other', prio = 35})

phelper:add_cmd('togglespellup', {func=cmd_togglespellup, help="toggle a spell to be a spellup regardless of what the mud says", sortgroup='Spells', prio=40})
phelper:add_cmd('toggleclan', {func=cmd_toggleclanskill, help="toggle a spell/skill to be a clan skill", sortgroup='Spells', prio=41})
phelper:add_cmd('searg', {func=cmd_searg, help="add an argument to be cast with a spell", sortgroup='Spells', prio=42})

phelper:add_cmd('export', {func=cmd_export, help="export current spell list as list of commands", sortgroup='Misc', prio=44})
phelper:add_cmd('info', {func=cmd_info, help="show info on a spell", sortgroup='Misc', prio=45})
phelper:add_cmd('check', {func=cmd_check, help="lists everything that needs to be checked before spellups begin", sortgroup='Misc', prio=46})
phelper:add_cmd('pause', {func=cmd_pause, help="pause spellup", sortgroup='Misc', prio=47})
phelper:add_cmd('resume', {func=cmd_resume, help="resume spellup", sortgroup='Misc', prio=48})
phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh affected spells", sortgroup='Misc', prio=49})

phelper:enable()

--phelper:addaardhelps{"Map", "Automap", "Maprun", "Maptags", "Speedwalks", "Academy-Geography"}
--phelper:addaardcmds{"map", "automap", "maprun", "tags", "runto"}

]]>
</script>
</muclient>
